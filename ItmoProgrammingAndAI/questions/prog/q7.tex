\subsection{Метапрограммирование. Шаблоны и Generics. Частичная специализация шаблонов.}

\subsubsection{Метапрограммирование}

\textbf{Метапрограммирование}~---~создание программ, которые создают другие программы как результат своей работы (либо — частный случай — изменяющие или дополняющие себя во время выполнения).

Метапрограммирование можно разделить на 2 направления: на стадии компиляции (генерация кода) и на стадии выполнения (самомодифицирующийся код).

Первое направление позволяет получить программу при меньших затратах времени и усилий, чем если бы программист писал её вручную. Второе — расширяет возможности программиста.

\textbf{Генерация кода} (это не обязательно)

При этом подходе код программы не пишется вручную, а создается автоматически программой-генератором на основе другой, более простой программы.
Такой подход приобретает смысл, если при программировании вырабатываются различные дополнительные правила (более высокоуровневые парадигмы, выполнение требований внешних библиотек, стереотипные методы реализации определенных функций и пр.). При этом часть кода теряет содержательный смысл и становится лишь механическим выполнением правил. Когда эта часть становится значительной, возникает мысль задавать вручную лишь содержательную часть, а остальное добавлять автоматически. Это и проделывает генератор. Реализуется 2 основными методами:

\begin{enumerate}
	\item  \emph{Шаблоны} (наиболее известные случаи применения — препроцессор C и шаблоны в C++). Решают задачу, если соблюдение «правил» сводится к вставке в программу повторяющихся (или почти повторяющихся) кусков кода. Помимо этого, обладают еще рядом достоинств: например, помогают повторному использованию.
	\item \emph{Внешнеязыковые средства} (пример: генераторы синтаксических и лексических анализаторов lex, yacc, bison). Применяются в случаях, если простых средств вроде шаблонов недостаточно. Язык генератора составляется так, чтобы автоматически или с минимальными усилиями со стороны программиста реализовывать правила парадигмы или необходимые специальные функции. Фактически, это — более высокоуровневый язык программирования, а генератор — не что иное, как транслятор.
	Генераторы пишутся, как правило, для создания специализированных программ, в которых очень значительная часть стереотипна, либо для реализации сложных парадигм (таких, как паттерны проектирования).
\end{enumerate}

\textbf{Самомодифицирующийся код} (это не обязательно)

Возможность изменять или дополнять себя во время выполнения превращает программу в виртуальную машину. Хотя такая возможность существовала уже давно на уровне машинных кодов (и активно использовалась, например, при создании полиморфных вирусов), с метапрограммированием обычно связывают перенос подобных технологий в высокоуровневые языки. Основные методы реализации:
\begin{enumerate}
	\item Интроспекция — представление внутренних структур языка в виде переменных встроенных типов с возможностью доступа к ним из программы. Позволяет во время выполнения смотреть, создавать и изменять определения типов, стек вызовов, обращаться к переменной по имени, получаемому динамически и пр.
	Например, Пространство имён System.Reflection и тип System.Type в .NET; классы Class, Method, Field в Java; представление пространств имен и определений типов через встроенные типы данных в Python
	\item  Интерпретация произвольного кода, представленного в виде строки.
	Существует естественным образом во множестве интерпретируемых языков, например eval() в PHP.
	Для C++ есть библиотека, позволяющая «на лету» компилировать и генерировать исполняемый код (используется урезанный компилятор gcc).
	Принципиальный недостаток технологий этого направления — неприменимость к компилируемым языкам. Можно ввести в такой язык интерпретатор, как в вышеуказанной библиотеке для С++, но это
	практически сведет на нет главное преимущество данных языков — производительность.
\end{enumerate}

\subsubsection{Шаблоны и Generics. Частичная специализация шаблонов.}

\textbf{Шаблоны:}

В языке C++ обобщённое программирование основывается на понятии «шаблон», обозначаемом ключевым словом template.

\begin{lstlisting}[language=C++]
	template < typename T> T max (T x , T y ) {
		if (x < y)
		return y;
		else
		return x;
	}
\end{lstlisting}

Интересное применение нашли шаблоны в языке C++. Оказалось, что шаблоны в этом языке являются тьюринг-полным функциональном языком. Другими словами на шаблонах С++ можно написать программу, реализующую произвольный алгоритм, и эта программа выполнится в момент компиляции.

К примеру, можно предпосчитать $50$-е число Фибоначчи. Тогда во время выполнения программы не придется тратить время на его вычисления. Одной интересной особенностью такого программирования на шаблонах, является встроенный механизм мемоизации (сохранения результата вычисления функции). Это значит, что рекурсивный алгоритм для вычисления k -го числа Фибоначчи работающий «в лоб» сделает порядка k операций (вместо ожидаемых 2k).

\begin{lstlisting}[language=C++]
	template <int i> struct fib { 
		static const int val = fib<i - 1>::val + fib<i - 2>::val;
	};
	template <> struct fib <1> { static const int val = 1; };
	template <> struct fib <2> { static const int val = 1; };
\end{lstlisting}

Но это не самое интересное: программирование на шаблонах С++ позволяет общаться с типом как с обычным объектом. К примеру, можно составить список типов, удалить из него все встроенные типы, а
из оставшегося списка создать объект, который будет унаследован от всех типов из данного списка. Для такого метапрограммирования была написана специальная библиотека MPL (MetaProgramming Library).

\textbf{Generics}

Язык Java предоставляет средства обобщённого программирования, синтаксически основанные на C++. В Java generics (параметризованные типы или родовые типы) имеют мнимое сходство с шаблонами C++ как
по синтаксису, так и по ожидаемому месту их применения (например, в качестве контейнерных классов).

Но это сходство только поверхностное — родовые типы в языке программирования Java почти полностью реализуются в компиляторе, который выполняет проверку типов и выявление типа (type inference)
и, затем, генерирует обычные не параметризованные байткоды. Такая техника реализации, называемая стиранием (когда компилятор использует информацию о родовом типе для контроля типов и удаляет ее перед генерированием байткода), имеет неожиданные, а иногда и непонятные последствия. В то время как родовые типы являются большим шагом на пути к безопасности Java-классов, изучение их использования почти наверняка будет вызывать некоторую озадаченность (а иногда и мучения).

\textbf{Частичная специализация шаблонов}

Если у шаблона класса есть несколько параметров, то можно специализировать его только для одного или нескольких аргументов, оставляя другие неспециализированными. Иными словами, допустимо написать шаблон, соответствующий общему во всем, кроме тех параметров, вместо которых подставлены фактические типы или значения. Такой механизм носит название частичной специализации шаблона класса. Она может понадобиться при определении реализации, более подходящей для конкретного набора аргументов. Например unique\_ptr имеет частичную специализацию для массивов (T[]).

\begin{lstlisting}[language=C++]
	template <typename T>
	class unique_ptr;
	
	template <typename T>
	class unique_ptr<T[]>;
\end{lstlisting}
Частичная специализация шаблона класса — это тоже шаблон, но список параметров здесь отличается от соответствующего списка параметров общего шаблона.